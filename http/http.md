## http

#### 1.基础概念篇

##### 1.1介绍

​	HTTP时Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会和Internet工作小组IETF的合作结果，他们最终发布了一些列的RFC，RFC1945定义了HTTP/1.0版本。其中最著名的就是RFC2616.RFC2616定义了而今天普遍使用的一个版本--HTTP1.0

​	HTTP协议用于从WWW服务器传输超文本到本地浏览器的传送协议。塔可以使浏览器更加高效，使网络传输减少。她不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的那一步部分，以及那部分内容首先显示等（如文本先于图形）。

​	***HTTP是一个应用层协议，由于请求和响应构成，是一个标准的客户端服务器模型。HTTp是一个无状态的协议***

##### 1.2在TCP/IP协议栈中的位置

​	HTTp协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层智商，这个时候，就完成了我们常说的HTTPS。如下图所示：

![image-20210927105710919](C:\Users\xfff\AppData\Roaming\Typora\typora-user-images\image-20210927105710919.png)

​	**默认HTTP的端口号为80，HTTPS的端口号为443**

##### 1.3HTTP的请求相应模型

​	HTTP协议永远都是客户端发起请求，服务器回送相应。如下图：

![image-20210927105819878](C:\Users\xfff\AppData\Roaming\Typora\typora-user-images\image-20210927105819878.png)

​	这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。

**http是一个无状态的协议，同一个客户端的这次请求和上次请求没有对应关系**

##### 1.4工作流程

​	一次HTTP操作称为一个事务，其中工作过程可分为四部：

1. ​	首先客户端与服务器需要建立连接。只要单机某个超链接，HTTP的工作开始

2. 建立连接后，客户端发送一个请求给服务器，请求方式的格式为：同一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的 内容。

3. 服务器接到请求后，介于相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或者错误的代码，后边是MINE信息包括服务器信息、实体信息和可能的内容。

4. 客户端接受服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

   用过在以上过程中出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

##### 1.5头域

​	每个头域由一个域名，冒号（：）和阈值三部分组成。域名是大小写无关的，阈值前可以添加任何数量的空格符，头域可以被扩展多行，在每行开始处，使用至少一个空格或制表符

###### 1.5.1Host头域

​	Host头域指定请求资源的internet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。

###### 1.5.2Referer头域

​	Referer头域允许客户端指定请求url的资源源地址，这可以允许服务器生成回退链表，可用来登录、优化cache等。他也循序报废的或错误的连接由于维护的目的被追踪。如果请求的rul没有自己的url地址，Referer不能被发送。如果指定的是部分url地址，则此地址应该是一个相对地址。

###### 1.5.3User-Agent头域

​	User-Agent头域的内容包含发出请求的用户信息

###### 1.5.4Cache-Control头域

​	Cache-Control指定请求和响应准寻的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改零一消息处理过程重点缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、.

###### 1.5.5Date头域

​	Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如Date：Mon，31Dec200101：25：57GMT。Date描述的时间表示世界标准时，换算成本地时间，v需要知道客户所在的时区。

##### 1.6HTTP的几个重要概念

###### 1.6.1连接：Connection

​	一个传输层的实际环流，他是建立在两个相互通讯的应用程序之间。

​	在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义时当client和server通信时对于长连接如何进行处理

​	在http1.1中，client使用http1.1协议，但又不希望使用长连接，则需要在header中指明connection的值为close；如果server方法也不想支持长连接，则在response中也需要说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp连接在当天请求处理完毕后被断掉。以后client在进行新的请求时，必须创建新的tcp连接

###### 1.6.2消息：Message

​	HTTp通讯的基本单位，包括一个结构化的把元组序列并通过连接传输

###### 1.6.3请求：Request

​	一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。

###### 1.6.4响应：Response

​	一个从服务器返回的信息包括HTTP协议的版本号、请求的状态和文档的MINE类型。

***MIME*(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。**

###### 1.6.5资源：Resource

**URI**，同一资源标志符，表示的时web上每一种可用的资源，如HTML文档、图像、视频片段、程序等都由一个URI进行标识的

组成：资源的命名机制，存放资源的主机名，资源自身的名称

**URL**是URI的一个子集。他是Uniform Resource Locator的缩写，译为“统一资源定位符”。

同属的说，URL是internet上描述信息资源的字符串，主要用在各种www客户程序和服务器程序上。

**两者区别**：URI和URL都定义了资源是什么，但URL还定义了如何访问资源。URL是一种具体的URI，他是URI的一个自己，它不仅唯一表示资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的。二URL则必须提供足够的信息来定位，是绝对的。

#### TCP建立连接的三次握手

![image-20211012141442286](img/image-20211012141442286.png)

1. TCP服务器进程先创建传输模块TCB，时刻准备接受客户进程的连接请求，此时服务器进入LISTEN状态
2. Tcp客户进程也是首先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，，同时选择一个初始序列号seq=x，此时和护短进入了SYN-SENT状态。TCP规定，SYN报文段不能携带数据，但需要消耗一个序列
3. TCP服务器收到请求报文后，如果同一连接，则发出确认报文。确认报文中应该ACK=1，SYN=1，确认好ack=x+1，同时也要为自己初始化一个序列号seq=y，此时，tcp服务器进程进入syn-rcvd状态。这个报文也不能携带数据，但是同样要消耗一个序列号
4. tcp客户进程收到确认后，还要向服务器给出确认。确认报文的ack=1，ack=y+1，自己 的序列号seq=x+1，此时tcp连接建立，客户端进入已建立连接状态。tcp规定，ack报文段可以携带数据，但是如果不懈怠数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入连接建立状态，此时可以通信

##### 为什么tcp客户端最好还要发送一次确认

1. 一句话，主要防止已经失效的连接请求报文突然由传送到了服务器，从而产生错误。如果使用的是两次握手连接，假设由这样一种场景，客户端发送了第一个请求连接，并没有丢失，只是因为在网络节点中直流的时间太长了，由于tcp的客户端迟迟没有收到确认报文。

#### tcp四次挥手

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=x，，此时客户端进入FIN-wait-1状态，tcp规定，fin报文段即使不懈怠数据，也要消耗一个序号
2. 服务器收到连接释放报文，发出确认报文，ack=1，ack=x+1，并且自己的seq=y，此时服务器进入close-wait状态。tcp服务器通知高层的应用进程，客户端向服务器的方向就释放了，此时处理版关闭状态，即客户端已经没有要发送的数据了，但是服务器要发送数据，客户端依然要接受，这个状态还要持续一段时间。也就是close-wait持续的时间
3. 客户端收到服务器的确认后，此时，客户端进入fin-wait-2状态，等待服务器发送连接释放报文。
4. 关闭服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，fin=1，ack=x+1，由于在办关闭状态，服务i去很可能由发送了一些数据，此时假定seq=w，此时服务器进入了last-ack状态，等待客户端的确认
5. 客户端收到服务器的连接释放报文后，必须发出确认，ack=1，ack=w+,自己的序列号是seq=x+1，此时客户端进入time-wait状态。注意此时tcp连接还没有释放，必须经过2msl（最长报文寿命）的时间后，客户端撤销响应的tcb后，才进入closed状态
6. 服务器只要收到了客户端发出的确认，立即进入colsed撞他。![image-20211012141430478](img/image-20211012141430478.png)

#### 为什么要等待最后2msl

msl，tcp允许不同的实现可以设置不能的msl值



