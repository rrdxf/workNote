### Mvcc原理

mvcc（multiversion concurrency control）中文全称叫多版本并发控制，是现代数据库包括mysql、oracle、postgersql引擎实现中常用的处理读写冲突的手段，目前在于提高数据库高并发场景下的吞吐性能。

如此一来不同的事务在并发过程中，select操作可以不加锁而是通过mvcc机制读取指定的版本历史记录，并通过一些手段保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下单 读写冲突

#### 为什么需要mvcc

innodb相比myisam有两大特点，一个是支持事务，一个是支持行级锁，事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的 利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题。

主要情况：

1. 更新丢失：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生更新丢失的问题--最后的更新覆盖了其他事务所作的更新。如何避免，最好在一个事务数据进行更新但没有提交的时候，其他事务不能访问修改同一个数据（读未提交）
2. 脏读：一个事务正在对一条记录左修改，在这个事务并提交签，这个记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不控制，第二个读取了这些尚未提交的脏数据，并据此左进一步处理，就会产生未提交的数据依赖关系，这种现象是脏读。(读未提交)
3. 不可重复读：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除。
4. 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，缺发现其他事务插入满足其查询条件的 新数据

加读写锁一致性快照，即mvcc

但本质上，隔离级别是一种在并发新跟那个和并发产生的副作用间的妥协，通常数据库均倾向于采用weak isolation。

innodb中的mvcc，应对高并发事务，mvcc比单纯的行锁有效，开销低。mvcc在读已提交和可重复读隔离级别下起作用。

#### 原理

innodb中mvcc的实现方式为：每一行记录都有连哥哥隐藏列：DATA_TRX_ID、DATA_ROLL_PTR(如果没有主键，则还会多一个隐藏的主键列)。

DATA_TRX_ID：记录最新更新这条行记录的事务ID、大小为6字节

DATA_ROLL_PTR：表示指向该行回滚段的指针，大小为7字节，innodb便是通过这个指针找到之前的版本数据。改行记录上所以有旧版本，在undo中都通过链表的形式组织

DB_ROW_ID：行标识、大小6，如果没有主键，innodb字节生成隐藏主键，因此会出现这个列。另外，每条记录的头信息里都有一个专门的bit来表示当前记录是否已经被删除。

##### 对于update

如何组织undo log链

在多个事务 并行操作某行数据的情况下，不同事务对该行数据的update会产生多个版本，然后通过回滚指针组织成一条undo log链。以下为实例：

务实A对值进行更新之后，该行即产生一个新版本和旧版本。假设之前插入改行的事务id为100，事务a的id为两百，该行的 隐藏主键为1.

事务a的操作过程为：

对DB_ROW_ID=1的这行记录排他锁

把改行原本的值拷到undo log中，DB_TRX_ID和DB_ROLL_PTR都不动。修改该行的值这是产生一个新版本，更新DATA_TRX_ID为修改记录事务的id，将db_roll_ptr指向刚刚拷贝到undo log链中的旧版本记录，这样就能那个通过db_roll_ptr找到这条记录的历史版本。如果对统一行记录执行连续的 update。undo log会组成一个链表，遍历这个链表，可以看到这条记录的变迁。。

==db_roll_ptr说到底就是undo log链表的表头指针==

记录redo log 包括undo log终端修改

##### 对于insert、和delete

insert会产生一条新记录，他的data_trx_id为当前插入记录的事务id；delete可以看作是一种特殊的update，就是软删除，真正的删除会在commit时，data_trx_id则记录下删除该记录的事务id。

#### 如何实现一致性读——readView

在ru（read uncommit）隔离级别下,直接读取版本的最新记录，对于seralizeable，则通过枷锁互斥来访问数据，那么不需要mvcc帮助。因此mvcc运行在rc（read commit）和rr（repeateble read  可重复读）,当innodb隔离几倍设置为二者之一时，select访问数据会用到版本链。

##### 核心问题版本连中，那些版本对当前事务可见？

innodb为了解决这个问题，设计了readview  ==可读视图== 的概念  

##### rr下的readview生成

在rr隔离级别下，每个事务touch first read时（本质上就是执行第一个select语句时，后续所有的select都是重复这个readview，其他update，delete，insert语句和一致性读snapshot的简历没有关系）会将当前系统中所有的活跃事务拷贝到一个列表生成readview

事务a第一条select语句在事务b更新数据前，因此生成的raedview 在事务a过程中不发生变化，即时事务b在事务a之前提交，但是事务a第二条查询语句依旧无法督导事务b的修改

==就是， 事务中第一个select执行时，会形成一个readview，这个readview不会因为其他事务中执行了update delete等操作而该改变，这样就解决了不可重复读。==

##### rc下的readview生成

在rc隔离几倍下，每个select语句开始时，都会重新将当前系统中所有的活跃事务拷贝到一个列表中生成readview。二者的区别在于生成readview的时间点不同，一个时事务之后第一个select语句开始，以恶搞时事务中每条select语句开始。

readview中是当前活跃事务id列表，称为m_ids，其中最小值为up_limit_id，最大值为low_limit_id,事务id的大小关系来决定版本记录的可见性，流程如下：

如果被访问的trx_id小于m_ids中的最小值up_limit_id，说明生成该版本的事务在readview生成前就提交了，所以该版本可以被当前事务访问。

如果被访问版本的trx_id大于m_ids列表中的最大值low_limit_id，说明生成该版本的事务在生成readview后才生成，所以该版本不可以被当前事务访问，需要根据undo log 链找到之前一个版本，然后根据该版本的db_trx_id重新判断可见性

r如果被访问 版本的trx_id属性值在m_ids咧白哦中最大值二号最小值之间，那就需要判断一些trx_id在不在m_ids列表中，如果在，说明readview时生成该版本所属事务还是活跃事务，则版本也不能被访问，需要找用版本链，然后重复计算

此时经过一些判断我们已经得到了这条记录相对readview来说的 可见结果。此时如果这条记录的delete_flag为true，说明这条记录已经被删除，不反悔。false，则说明可以安全返回给客户端

##### rr下的mvcc判断流程

在rr隔离级别下，值生成一次readview ，那么区间只有200--300,所以无论事务b是否提交了，readview 的trx_ids列表的范围不会改变，所以都判定b事务的修改不可访问，所以都是10

##### 争论点：、

其实并非所有的情况都恩尼格套用mvcc读的判断流程，特别是在事务进行过程中，另一个事务已经提交修改的情况下，这时，不论是rc还是rr，直接套用mvcc判断都会有问题，例如，在rc下：

事务a的trx_id=200，事务b的trx_id=300，且事务b修改了数据之后再事务a提交之前

























