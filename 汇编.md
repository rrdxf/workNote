### 汇编

### 第一章：基础知识

#### 汇编语言：

- 汇编指令（机器码的助记符）
- 伪指令（由编译器执行）
- 其他符号（编译器识别）

汇编语言的核心是汇编指令，它决定 了汇编语言的特性

#### 存储器

cpu是计算机的核心不见，它控制整个计算机的运作并行计算，想要让一个cpu工作，就必须向他提供指令和数据

指令和数据在存储器中存放，也就是平时所说的内存。

一台pc内存作用仅词语cpu

离开了内存，性能再好的cpu也无法工作。

磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用

#### 指令和数据：

在内存或磁盘上。指令和数据没有任何区别

#### 存储单元

存储器被划分为若干个存储单元，每个存储器都被划分为若干个存储单元

#### cpu对存储器的读写

![1639364207984](C:\Users\xf\Desktop\学习笔记\assets\1639364207984.png)

物理上：一根导线的集合

逻辑上：地址总线、数据总线、控制总线

#### 地址总线

cpu是通过地址总线来指定存储单元

地址总线上能传送多少个不同的信息，cpu就可以对多少个存储单元进行寻址![1639364864579](C:\Users\xf\Desktop\学习笔记\assets\1639364864579.png)

一个cpu有n根地址总线，则可以说这个cpu的地址总线宽度为n。这样的cpu最多可以寻找2的n次方个内存单元

#### 数据总线

cpu与内存或其他器件之间的数据攒送是通过数据总线来进行的。数据总线的宽度决定了cpu和外界传送的速度

#### 内存地址空间

一个cpu的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个cpu的内存地址空间

#### 主板

在pc中有主板，主板上有核心器件和一些主要器件。这些器件通过总线（地址总线、数据总线、控制总线）相连。

#### 接口

计算机中，所有可用程序控制其工作的设备，必须收到cpu的控制。cpu对外部设备不能直接控制，如显示器、音响，打印机等。直接控制这些设备进行工作的是插在扩展槽上的接口卡、

#### 存储芯片

从读写属性上分为：

- 随机存储器(ram)和只读存储器(rom)

从功能和连接上分类：

- 随机存储器ram

- 装有bios的rom：
  - bios：basic input/output system，基本输入输出系统

- 接口卡上的ram
  - bios是由主板和各类接口卡（显卡、网卡）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口上插有存储相应的bios的rom

![1639366092905](C:\Users\xf\Desktop\学习笔记\assets\1639366092905.png)

#### 内存地址空间

上诉的存储器在物理上是独立的器件。

但是在以下两点相同：

- 都和cpu的总线相连
- cpu对他们进行读或写的时候都通过控制线发出内存读写命令

### 第二章：cpu工作原理

#### 概述

一个典型的cpu由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。

区别：

内部总线实现cpu内部各个器件之间的联系

外部总线实现cpu和主板上其他器件的联系

#### 寄存器

![1639445308816](C:\Users\xf\Desktop\学习笔记\assets\1639445308816.png)

AX,BX,CX,DX都是通用寄存器，16位寄存器的逻辑结构

#### 物理地址

cpu访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间

我们将这个唯一的地址称为物理地址

#### 16位结构的cpu

概括的讲，16位结构描述了一个cpu具有以下几个方面特征

1. 运算器一次最多可以处理16位的数据
2. 寄存器的最大宽度位16位
3. 寄存器二号运算器之间的通路是16位的

#### 8086cpu给出物理地址的方法

![1639533234210](C:\Users\xf\Desktop\学习笔记\assets\1639533234210.png)

#### 段的概念

错误：内存被划分成了一个一个的段，每一个段有一个段地址

其实：内存并没有分段，段的划分来自于cpu，由于8086cpu用（段地址x16）+偏移地址=物理地址 的方式给出内存端元的物理地址，是的我们可以划分的方式来管理内存

**注意**

1. 偏移地址位16位，64kb，那么一个段的长度是64kb

#### 段寄存器

段寄存器就是提供段的地址

8086cpu有4个段地址寄存器

##### cs和ip



cs和ip是8086中最关键的寄存器，他们只是了cpu当前要读取指令的地址

修改cs、ip中的内容

jmp 短地址：偏移地址

jmp 2ae3：3

jmp 3：0b16

cs:保存代码段基址

##### ds：数据段的基址

##### ss

##### es：扩展段寄存器

当8086cpu要访问内存时，由这4个段寄存器提供内存端元的段地址

#### debug指令用法

r：![1639619577855](C:\Users\xf\Desktop\学习笔记\assets\1639619577855.png)

查看当前寄存器的内容

e:查看内存中的内容

a：以汇编指令的形式把内容写入内存

t：执行

### 第三章：寄存器

#### 内存中字的存储

任何两个地址连续的内存单元，n号单元和n+1号单元，可以将他们看成两个内存单元，也可以堪称一个地址位n的字单元中的高位字节单元和地位字节单元

#### ds和[address]

- cpu要读取一个内存单元的时候，必须给出这个内存单元的地址
- 在8086pc中，内存地址由短地址和偏移地址组成
- 8086cpu中由一个ds寄存器，通常用来存放要访问的数据的段地址

#### 字的传送

​	因为8086是16位结构，有16根数据线，所以，可以一次性攒送16位的数据，也就是一次性传送一个字

#### mov、add、sub指令

mov 寄存器，数据

mov 寄存器，寄存器

mov 寄存器，内存单元

mov 内存单元，寄存器

mov 段寄存器，寄存器

#### 数据段

​	对于8086，我们可以根据需要将一组内存单元定义为一个段（也可以是代码段，数据段等）

​	我们可以将一组数组长度位n（n<64k）、地址连续，起始地址位16的背书的内存单元当作专门存储数据的内存空间，从而定义了一个数据段

![1639622643306](C:\Users\xf\Desktop\学习笔记\assets\1639622643306.png)

##### 总结

1. 字在内存中存储时，要用连哥哥地址连续的内存单元来存放，字的地位字节存放在低地址单元中，高位字节存放再高地址单元中
2. 用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时短地址默认在ds寄存器中
3. [adress]表示偏移地址
4. 在底村和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低位寄存器相对应
5. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令

#### 栈

##### cpu如何知道当前要执行指令所在的位置

**答：**寄存器cs和ip中存放着当前指令的段地址和偏移地址

8086cpu中，有两个寄存器：

​	段寄存器ss： 存放栈顶的段地址

​	寄存器sp:  存放栈顶的偏移地址

任意时刻，ss：sp指向栈顶元素

##### push ax

​	sp=sp-2

##### pop ax

​	将ss：sp指向的内存单元数据传送

​	sp=sp+2

##### 当位空栈时：9

![1639623789998](C:\Users\xf\Desktop\学习笔记\assets\1639623789998.png)

##### 栈顶越界的问题

是危险的 ，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据，代码。这些数据代码可能是我们自己的程序中的，也可能是北大程序中的。

#### 栈段

前面讲过，对于8086pc机，在编译过程时，我们可以根据需要，将一组内存单元定义为以恶搞段

我们可以将长度为n（n<=64kb）的一组地址连续、其实地址为16的背书的内存单元，当作栈来使用，从而定于i个一个栈段

​	将一段内u才能当作栈段，仅仅是我们在编程时的一种安排，cpu并不会由于这种安排，就在执行push、pop等操作指令时就自动地将我们定义的栈段当作栈空间来访问

### 第四章：第一个程序

​	用编译器将他们编译成为可执行文件（如：*.exe文件）,在操作系统中运行

#### 可执行文件

- 程序（从原程序中的灰白你指令翻译过来的机器码）和数据（源程序中定义的数据）
- 相关描述信息（如程序多大）

#### 源程序

##### 伪指令：

​	编译器看的指令：segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令

end是程序结束

ends是segment结束

##### 汇编指令

##### 注意：

​	我们可以将源程序文件中所有的内容称为源程序，将源程序中最终由计算机执行处理的指令或数据，成为程序

​	程序最先以汇编指令的形式存在源程序中，经编译，连接后转变为机器码，存储在可执行文件中

#### 标号

标号代表一个地址

codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的地址

#### 关于编译和链接

编译链接的作用

1. 当源程序很大时，可以将它划分为多个源程序文件来百衲衣，每个源程序编译成目标文件之后，再用连接程序将他们连接到一起，生产一个可执行文件；
2. 程序中，调用了某个库文件中的子程序，需要将这个库文件和该程序生产的目标文件连接到一起，生产以恶搞可执行文件；
3. 一个源程序百衲衣之后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生产可执行文件，连接程序将此内容处理为最终的可执行信息。所以在只有一个源程序文件，而由不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件

#### 可执行文件中的程序装入内存并运行的原理

在dos中，可指导性文件中的程序p1若要运行，必须由一个正在运行的程序p2，将p1从可执行文件中加载入内存，将cpu的控制权交给它，p1才能得以运行

当p1运行完毕后，应该将cpu的控制权交换给使它得以运行的程序p2.

![1639645022120](C:\Users\xf\Desktop\学习笔记\assets\1639645022120.png)

### LOOP指令

cx中存放loop循环的次数

![1647395014965](C:\Users\xf\Desktop\学习笔记\assets\1647395014965.png)

jmp short ip+8 的位移

jmp near ip+- 16位（+-32769）

jmp far 



### jcxz  :短转移

cx=0时， ip+8跳转

cx!=0 ，不跳转

### call和ret

cs 和 ip 的转移指令